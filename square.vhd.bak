library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.STD_LOGIC_UNSIGNED.ALL;

entity Square is
    Generic( width : integer := 9);
    Port(
        reset       : in STD_LOGIC;
        clk         : in STD_LOGIC;
        amp         : in STD_LOGIC_VECTOR(width-1 downto 0);
        Period      : in STD_LOGIC_VECTOR(width-1 downto 0);
        PWM_OP      : out STD_LOGIC
    );
end Square;

architecture Behavioral of Square is
    --Add signals here
    --type stateType is (S0, S1);
    --signal CurrentState, NextState  : stateType;
    signal PWM_DAC_OP   : STD_LOGIC;
    signal HALF_PERIOD  : STD_LOGIC_VECTOR(width-1 downto 0);
    signal count        : STD_LOGIC_VECTOR(width-1 downto 0);
    constant zeroes     : STD_LOGIC_VECTOR(width-1 downto 0) := (others => '0');


component PWM_DAC is
    Generic( width : integer );
    Port(
        reset      : in STD_LOGIC;
        clk        : in STD_LOGIC;
        duty_cycle : in STD_LOGIC_VECTOR (width-1 downto 0);
        pwm_out    : out STD_LOGIC
    );
end component;

begin
    HALF_PERIOD(width-1) <= '0';
    HALF_PERIOD(width-2 downto 0) <= Period(width-1 downto 1); --shifts period right by 2
                                                               --which divides period by two


    PWM_OP <= PWM_DAC_OP when amp >= count else '0';
    sequential: process(clk, reset)
        begin
            if (reset = '1') then
                count <= zeroes;
            elsif (rising_edge(clk)) then
                if count = Period then
                    count <= zeroes;
                else
                    count <= count + '1';
                end if;
            end if;
    end process ;

    DAC:    PWM_DAC
        generic map(width => width)
        port map (
            reset       => reset,
            clk         => clk,
            duty_cycle  => amp,
            pwm_out     => PWM_DAC_OP
        );
    --
end Behavioral;
